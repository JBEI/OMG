#!/usr/bin/env python3
"""
omg: Omics Mock Generator

Generates a mock dataset of omics data (importable in EDD):
transcriptomics, proteomics, and metabolomics
"""

__author__ = 'LBL-QMM'
__copyright__ = 'Copyright (C) 2019 Berkeley Lab'
__license__ = 'GNU Affero General Public License Version 3'
__status__ = 'Alpha'
__date__ = 'Oct 2019'
__version__ = '0.0.1'

import argparse
import os
import random
import sys
import warnings
from collections import OrderedDict
from enum import Enum
from typing import NewType, Dict, List, Any

import cobra
import pandas as pd
from cobra.exceptions import OptimizationError

# Type annotations
Filename = NewType('Filename', str)


# Enumerations
class Omics(Enum):
    """Enumeration with supported omics data types."""
    PROTEOMICS = 0
    TRANSCRIPTOMICS = 1
    METABOLOMICS = 2

    def __str__(self):
        return f'{str(self.name).lower()}'


# Constants
# TODO: Move some constants to variables by program arguments
DATA_FILE_PATH: Filename = Filename('data')
MODEL_FILENAME: Filename = Filename('iECIAI39_1322.xml')
REACTION_ID: str = 'BIOMASS_Ec_iJO1366_core_53p95M'
UNITS: Dict[Omics, str] = {
    Omics.PROTEOMICS: 'proteins/cell',
    Omics.TRANSCRIPTOMICS: "FPKM",
    Omics.METABOLOMICS: "g/L"
}
# Fix the flux value to -15 as we have data for this constraint
LOWER_BOUND: int = -15
UPPER_BOUND: int = -15


def ansi(num: int):
    """Return function that escapes text with ANSI color n."""
    return lambda txt: f'\033[{num}m{txt}\033[0m'


# pylint: disable=invalid-name
gray, red, green, yellow, blue, magenta, cyan, white = map(ansi,
                                                           range(90, 98))


# pylint: enable=invalid-name


def main():
    """Main entry point to the script."""

    def add_random_noise():
        # TODO
        """

        :return:
        """
        pass

    def check_debug():
        """Check debugging mode"""
        if args.debug:
            print(blue('INFO:'), gray('Debugging mode activated'))
            print(blue('INFO:'), gray('Active parameters:'))
            for key, val in vars(args).items():
                if val is not None and val is not False and val != []:
                    print(gray(f'\t{key} ='), f'{val}')
        elif not sys.warnoptions:
            warnings.simplefilter("ignore")

    def dict_to_edd(omics_dict: Dict[str, float],
                    omics: Omics) -> pd.DataFrame:
        """Get dataframe with EDD format from dictionary with omics values"""

        edd: List[OrderedDict[str, Any]] = []
        sample: OrderedDict[str, Any]

        for measurement, value in omics_dict.items():
            sample = OrderedDict([
                ('Line Name', 'WT'),
                ('Measurement Type', measurement),
                ('Value', value),
                ('Units', UNITS[omics])
            ])
            edd.append(sample)

        return pd.DataFrame(edd)

    def generate_mock_data(model, cond):
        """

        :param model: cobra model object
        :param solution: solution for the model optimization using cobra
        :param data_type: defines the type of -omics data to generate (all by default)
        :return:
        """

        while cond:
            print(gray('Condition parameter:'), magenta(cond))
            cond -= 1
            optimize_solution(model, REACTION_ID)
            solution: cobra.Solution = cobra.core.solution.get_solution(
                model, raise_error=False)

            write_experiment_description(cond)

            # TODO: Uncomment next lines once methods adapted
            get_proteomics_transcriptomics_data(model, solution, cond)
            get_metabolomics_data(model, cond)

    def get_metabolomics_data(model: cobra.Model, cond: int):
        """

        :param model:
        :param cond:
        :return:
        """

        metabolomics: Dict[str, float] = {}  # metabolites and concentrations

        # TODO: Need to find a better algorithm. This is O(n^3)
        for met in model.metabolites:
            # get associated reactions
            for reaction in list(met.reactions):
                for metabolite, coefficient in reaction.metabolites.items():
                    if metabolite.id == met.id:
                        if met.id not in metabolomics.keys():
                            metabolomics[met.id] = abs(coefficient)
                        else:
                            metabolomics[met.id] += abs(coefficient)
            # TODO: Check this -> getting number of associated reactions and averaging the metabolic ??concentration?? value
            num_reactions = len(list(met.reactions))
            metabolomics[met.id] /= num_reactions

        metabolomics_df: pd.DataFrame = dict_to_edd(
            metabolomics, Omics.METABOLOMICS)

        # Write metabolomics file
        write_data_files(metabolomics_df, Omics.METABOLOMICS, cond)

    def get_proteomics_transcriptomics_data(model: cobra.Model,
                                            solution: cobra.Solution,
                                            cond: int):
        """

        :param model:
        :param solution:
        :param cond:
        :return:
        """
        # Pre-determined linear constants
        prote_scaling = 0.8  # Scaling factor for fluxes to proteomics
        trans_scaling = 0.6  # Scaling factor for proteomics to transcriptomics
        # TODO: Allow user to set those constants via parameters

        # Get values for proteomics and transcriptomics
        proteomics: Dict[str, float] = {}
        transcriptomics: Dict[str, float] = {}

        rxnIDs: pd.Index = solution.fluxes.index
        for rxnId in rxnIDs:
            reaction: cobra.Reaction = model.reactions.get_by_id(rxnId)
            for gene in reaction.genes:
                protein_id: str = ''
                # WARNING! Based on gene.annotation property populated
                protein_db: str = ''
                for protein_db in ['uniprot', 'goa', 'ncbigi']:
                    try:
                        protein_id = gene.annotation[protein_db]
                    except KeyError:
                        pass
                    else:
                        # Populates proteomics and transcriptomics dicts
                        proteomics[protein_id] = (
                                solution.fluxes[rxnId] / prote_scaling)
                        transcriptomics[gene.id] = (
                                proteomics[protein_id] / trans_scaling)
                        break
                else:
                    vprint(yellow('WARNING!'), gray('Gene'), gene.id,
                           gray('in reaction'), rxnId,
                           gray('has no useful annotation. Skipping...'))

        proteomics_df: pd.DataFrame = dict_to_edd(
            proteomics, Omics.PROTEOMICS)
        transcriptomics_df: pd.DataFrame = dict_to_edd(
            transcriptomics, Omics.TRANSCRIPTOMICS)

        # Write proteomics and transcriptomics files
        write_data_files(proteomics_df, Omics.PROTEOMICS, cond)
        write_data_files(transcriptomics_df, Omics.TRANSCRIPTOMICS, cond)

    def get_random_number():
        """

        :return:
        """
        random.seed(12312)
        return random.random()

    def optimize_solution(model: cobra.Model, reaction_id: str) -> None:
        """

        :param model:
        :param reaction_id:
        :return solution:
        """

        vprint(gray('Reaction:'),
               model.reactions.get_by_id(reaction_id))
        # Set local reaction bounds
        model.reactions.get_by_id(reaction_id).lower_bound = LOWER_BOUND
        model.reactions.get_by_id(reaction_id).upper_bound = UPPER_BOUND
        vprint(gray('Displaying the reaction bounds after constraining them:'),
               blue(model.reactions.get_by_id(reaction_id).bounds))
        # Optimize the model using FBA
        print(gray('Optimizing the model using FBA... '), end='')
        model.slim_optimize()
        try:
            cobra.util.assert_optimal(model)
        except OptimizationError as error:
            print(yellow('PROBLEM!'), error)
        else:
            print(green('OK!'))

    def print_reactions(model):
        """

        :param model:
        :return: None (prints the list of reactions that have BIOMASS in them)
        """

        # Print out the reaction name and reaction id for all reactions
        #   related to BIOMASS production:
        vprint(gray('List of reactions related to BIOMASS production:'))
        for rxn in model.reactions:
            if rxn.name is not None and 'BIOMASS' in rxn.id:
                vprint(f"{rxn.id} : {rxn.name}")

    def read_model(file_name):
        """

        :param file_name:
        :return model:
        """

        # Check presence of model file
        if not os.path.isfile(file_name):
            print(red('ERROR!'),
                  f'File {file_name} missing from the data dir!')
            raise IOError('Missing file')

        # Load model depending on the kind of file
        vprint(gray(f'Loading model in {file_name}... '), end='')
        if file_name.endswith(".xml"):
            model = cobra.io.read_sbml_model(file_name)
        elif file_name.endswith(".json"):
            model = cobra.io.load_json_model(file_name)
        else:
            print(red('ERROR!'),
                  f'File {file_name} type not supported!')
            raise TypeError('Unsupported file format')
        vprint(green('OK!'))

        return model

    def vprint(*a, **k):
        """Print only if verbose mode is enabled"""
        if args.verbose:
            print(*a, **k)

    def write_data_files(edd: pd.DataFrame, omics: Omics = None,
                         cond: int = 1) -> None:
        """
        Write the EDD dataframe into a xlsx file

        :param edd:
        :param omics:
        :param cond:
        :return:
        """
        omics_fname: Filename = Filename(
            os.path.join(DATA_FILE_PATH,
                         f'{omics}_mock{cond}.xlsx'))
        print(gray('Saving file'), magenta(omics_fname), gray('... '), end='')
        try:
            edd.to_excel(omics_fname,
                         sheet_name=f'{omics}',
                         index=False)
        except IOError as ex:
            print(red('ERROR!'))
            vprint(ex)
        else:
            print(green('OK!'))

    def write_experiment_description(cond=1):
        """

        :param cond:
        :return:
        """

        exp_desc_fname: Filename = Filename(
            os.path.join(
                DATA_FILE_PATH,
                f'EDD_Omics_Experiment_Description_mock{cond}.xlsx'))
        index_label = 'Line Name'
        exp_desc_cols = pd.Index([
            'Line Description',
            'Media',
            'Shaking speed',
            'Starting OD',
            'Culture Volume',
            'Flask Volume',
            'Growth Temperature',
            'Replicate Count',
        ], name=index_label)
        metadata_wt: Dict[str, Dict[str, Any]] = {'WT': {
            'Line Description': 'R. Opacus wild type (mock)',
            'Media': 'M9+glucose',
            'Shaking speed': 1.0,
            'Starting OD': 0.1,
            'Culture Volume': 50.0,
            'Flask Volume': 200.0,
            'Growth Temperature': 30.0,
            'Replicate Count': 1,
        }}
        exp_desc_df = pd.DataFrame.from_dict(metadata_wt,
                                             orient='index',
                                             columns=exp_desc_cols)
        exp_desc_df.to_excel(exp_desc_fname,
                             sheet_name='EXP_DESC',
                             index_label=index_label)

    # Argument Parser Configuration
    parser = argparse.ArgumentParser(
        description='Omics Mock Generator',
        epilog='%(prog)s -- {}'.format(__date__),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        '-d', '--debug',
        action='store_true',
        help='enable debug mode (implies verbose mode)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='enable verbose mode'
    )
    parser.add_argument(
        '-V', '--version',
        action='version',
        version='%(prog)s release {} ({})'.format(__version__, __date__)
    )

    # Parse arguments
    args = parser.parse_args()

    # Program header
    print('\n=-= {} =-= v{} - {} =-= by {} =-=\n'.format(
        sys.argv[0], __version__, __date__, __author__))

    # Select cases depending on the debug flag
    check_debug()

    # if data folder doesn't exist create it
    if not os.path.isdir(DATA_FILE_PATH):
        os.mkdir(DATA_FILE_PATH)

    filename: Filename = Filename(os.path.join(DATA_FILE_PATH, MODEL_FILENAME))
    # reaction_id = 'EX_glc__D_e'

    # read model
    model = read_model(filename)

    # Set global reactions bounds (in addition to local)
    cobra_config = cobra.Configuration()
    cobra_config.bounds = LOWER_BOUND, UPPER_BOUND

    # Print the list of reaction names related to BIOMASS production
    print_reactions(model)

    # get fake proteomics data and write it to XLSX file
    condition = 1
    generate_mock_data(model, condition)


if __name__ == "__main__":
    # TODO: Ask for filename and reaction name and then generate the mock data
    main()
