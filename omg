#!/usr/bin/env python3

"""
omg: Omics Mock Generator

Generates a mock dataset of omics data (importable in EDD):
transcriptomics, proteomics, and metabolomics

Requirements: Python 3.7.2, cobra, numpy, pandas.
"""

__author__ = 'LBL-QMM'
__copyright__ = 'Copyright (C) 2019 Berkeley Lab'
__license__ = 'GNU Affero General Public License Version 3'
__status__ = 'Alpha'
__date__ = 'Dec 2019'
__version__ = '0.0.1'

import argparse
import collections as col
import os
import random
import re
import statistics
import sys
import urllib.parse
import urllib.request
import warnings
from enum import Enum
from typing import NewType, Dict, List, Any, OrderedDict, Counter

import cobra
import numpy as np
import pandas as pd
from cobra.exceptions import OptimizationError, Infeasible

# Type annotations
Filename = NewType('Filename', str)

# Enumerations
class Omics(Enum):
    """Enumeration with supported omics data types."""
    PROTEOMICS = 0
    TRANSCRIPTOMICS = 1
    METABOLOMICS = 2

    def __str__(self):
        return f'{str(self.name).lower()}'


# Constants
UNIPROT_URL = '''https://www.uniprot.org/uploadlists/'''
CTS_URL = '''https://cts.fiehnlab.ucdavis.edu/rest/convert/'''
# HOST NAME
HOST_NAME: str = 'ropacus' 
# TODO: Move some constants to variables by program arguments
DATA_FILE_PATH: Filename = Filename('data')
# MODEL_FILENAME: Filename = Filename('iECIAI39_1322.xml')  # E. coli
MODEL_FILENAME: Filename = Filename('reannotated_base_v3.sbml')  # R. opacus
REACTION_ID_ECOLI: str = 'BIOMASS_Ec_iJO1366_core_53p95M'  # E. coli
REACTION_ID: str = 'biomass_target'  # R. opacus
# REACTION_ID: str = 'SRC_C00185_e'  # R. opacus
GENE_IDS_DBS: List[str] = ['kegg.genes']  # R. opacus
# GENE_IDS_DBS: List[str] = ['uniprot', 'goa', 'ncbigi']  # E. coli
UNITS: Dict[Omics, str] = {
    Omics.PROTEOMICS: 'proteins/cell',
    Omics.TRANSCRIPTOMICS: "FPKM",
    Omics.METABOLOMICS: "mg/L"
}
# Fix the flux value to -15 as we have data for this constraint
LOWER_BOUND: int = -15
UPPER_BOUND: int = -15

# Internals
_EPS = np.finfo(np.double).eps


def ansi(num: int):
    """Return function that escapes text with ANSI color n."""
    return lambda txt: f'\033[{num}m{txt}\033[0m'


# pylint: disable=invalid-name
gray, red, green, yellow, blue, magenta, cyan, white = map(ansi,
                                                           range(90, 98))


# pylint: enable=invalid-name

#==============================================================================

class Ecoli():

    def __init__(self):
        self.time_series_omics_data = {}
        self.proteomics = {}
        self.transcriptomics = {}
        self.fluxomics = {}
        self.metabolomics = {}
        self.LOWER_BOUND = -15
        self.UPPER_BOUND = -15


    def generate_time_series_data(self, model, condition):

        # intiializing omics dictionaries to contain data across timepoints
        proteomics_list: List = []
        transcriptomics_list: List = []
        fluxomics_list: List = []
        metabolomics_list: List = []

        # generating time series data for the following flux constraints
        # 6, 9, 12, 15 corresponding to the times 0, 3, 6, 9 hours
        time_series_omics_data = {}
        experiment_timepoints = [0, 3, 6, 9]
        flux_constraints = [6, 9, 12, 15]
        for i in range(len(flux_constraints)):
            # Set global reactions bounds (in addition to local)
            self.LOWER_BOUND = -flux_constraints[i]
            self.UPPER_BOUND = -flux_constraints[i]
            cobra_config = cobra.Configuration()
            cobra_config.bounds = self.LOWER_BOUND, self.UPPER_BOUND

            # Print the list of reaction names related to BIOMASS production
            # print_reactions(model)

            # get fake proteomics data and write it to XLSX file
            condition = 1
            proteomics, transcriptomics, fluxomics, metabolomics = self.generate_fake_data(model, condition)

            # appending the dictionaries to a master list that keeps track of the timepoints associated with the data generated
            proteomics_list.append((proteomics, experiment_timepoints[i]))
            transcriptomics_list.append((transcriptomics, experiment_timepoints[i]))
            fluxomics_list.append((fluxomics, experiment_timepoints[i]))
            metabolomics_list.append((metabolomics, experiment_timepoints[i]))
        
        time_series_omics_data = {'proteomics': proteomics_list, 'transcriptomics': transcriptomics_list, 'fluxomics': fluxomics_list, 'metabolomics': metabolomics_list}
        
        self.write_experiment_description_file(condition)
        self.write_omics_files(time_series_omics_data)


    def generate_fake_data(self, model, condition):
        """

        :param model: cobra model object
        :param solution: solution for the model optimization using cobra
        :param data_type: defines the type of -omics data to generate (all by default)
        :return:
        """

        self.proteomics = {}
        self.transcriptomics = {}
        self.fluxomics = {}
        self.metabolomics = {}

        # reaction_id of choice passed to the function# hardcoded here for this particular file (Need to convert this to an interactive cli program)
        reaction_id = REACTION_ID_ECOLI

        # while condition:
            # print("Condition parameter: ", condition)
        condition-=1
        solution = self.get_optimized_solution(model, reaction_id)
        # solution: cobra.Solution = cobra.core.solution.get_solution(
        #     model, raise_error=False)

        proteomics, transcriptomics, fluxomics = self.get_proteomics_transcriptomics_fluxomics_data(model, solution, condition)
        
        metabolomics = self.get_metabolomics_data(model, condition)
        
        return (proteomics, transcriptomics, fluxomics, metabolomics)


    def get_metabolomics_data(self, model, condition):
        """

        :param model:
        :param condition:
        :return:
        """
        metabolomics = {}
        # get metabolites
        # NOTE: Need to find a better algorithm. This is O(n^3)
        for met in model.metabolites:
            # get associated reactions
            for reaction in list(met.reactions):
                # get dictionary of associated metabolites and their concentrations
                for metabolite, conc in reaction._metabolites.items():
                    if metabolite.id == met.id:
                        # map the BIGG ids to CIDs using the inchikeys in the metabolites and the ampping file
                        # that we have generated from Pubchem
                        # remember that not all Inchikeys dont have a mappping to a CIDs and there are
                        # multiple mappings for some Inchikeys
                        if met.id not in metabolomics.keys():
                            metabolomics[met.id] = abs(conc)
                        else:
                            metabolomics[met.id] += abs(conc)
            # getting number of associated reactions and averaging the metabolic concentration value
            num_reactions = len(list(met.reactions))
            metabolomics[met.id]/=num_reactions

        return metabolomics


    def get_proteomics_transcriptomics_fluxomics_data(self, model, solution, condition):
        """

        :param model:
        :param solution:
        :param condition:
        :return:
        """

        # pre-determined linear constant (NOTE: Allow user to set this via parameter)
        # DISCUSS!!
        k = 0.8
        q = 0.06

        proteomics = {}
        transcriptomics = {}
        fluxomics = {}

        # print(solution.fluxes['EX_cm_e'])
        rxnIDs = solution.fluxes.keys()
        for rxnId in rxnIDs:
            reaction = model.reactions.get_by_id(rxnId)
            for gene in list(reaction.genes):

                # this will ignore all the reactions that does not have the gene.annotation property
                # DISCUSS!!
                if gene.annotation:
                    if 'uniprot' not in gene.annotation:
                        if 'goa' in gene.annotation:
                            protein_id = gene.annotation['goa']
                            # print("HERE")
                        else:
                            break
                    else:
                        protein_id = gene.annotation['uniprot'][0]
                        # print("HERERERERERERERER")

                    # create proteomics dict
                    # Adding noise which is 5% of the signal data. signal + signal*0.05 = signal*1.05
                    # print(rxnId)
                    # print(solution.fluxes)
                    # print(type(solution.fluxes))
                    # print(solution.fluxes[rxnId])
                    # print(protein_id)

                    proteomics[protein_id] = (solution.fluxes[rxnId]/k)*1.05
                    fluxomics[rxnId] = solution.fluxes[rxnId]

                # create transcriptomics dict
                transcriptomics[gene.id] = (proteomics[protein_id]/q)*1.05

        return proteomics, transcriptomics, fluxomics

    def write_experiment_description_file(self, condition=1, line_name='WT'):
        # create the filename
        experiment_description_file_name = f'{DATA_FILE_PATH}/experiment_description_file.csv'

        #write experiment description file
        try:
            with open(experiment_description_file_name, 'w') as fh:
                fh.write(f'Line Name, Line Description, Part ID, Media, Shaking Speed, Starting OD, Culture Volume, Flask Volume, Growth Temperature, Replicate Count\n')
                fh.write(f"{line_name}, KEIO wild type, ABF_001327, M9, 1, 0.1, 50, 200, 30, 1\n")
        except Exception as ex:
            print("Error in writing file!")
            print(ex)

        fh.close()


    def write_omics_files(self, time_series_omics_data, condition=1, line_name='WT'):
        """

        :param dataframe:
        :param data_type:
        :param condition:
        :return:
        """

        # create file number two: omics file
        # TODO: Need to change the units to actual relevant units
        unit_dict = { "fluxomics": 'g/L',\
                "proteomics": 'proteins/cell',\
                "transcriptomics": "FPKM",\
                "metabolomics": "mg/L"
                }

        # for each omics type data
        for omics_type, omics_list in time_series_omics_data.items():
            # create the filenames
            omics_file_name: str = f'{DATA_FILE_PATH}/{omics_type}_fakedata_sample_{condition}.csv'
            
            # open a file to write omics data for each type and for all timepoints and constraints
            try:
                with open(omics_file_name, 'w') as fh:
                    fh.write(f'Line Name,Measurement Type,Time,Value,Units\n')
                    for omics_dict, timepoint in omics_list:
                        dataframe = pd.DataFrame.from_dict(omics_dict, orient='index', columns=[f'{omics_type}_value'])
                        for index, series in dataframe.iteritems():
                            for id, value in series.iteritems():
                                fh.write((f'{line_name},{id},{timepoint},{value},{unit_dict[omics_type]}\n'))

            except Exception as ex:
                print("Error in writing file!")
                print(ex)
        
            fh.close()



    def get_random_number(self):
        """

        :return:
        """
        random.seed(12312)
        return random.random()

    def add_random_noise(self):
        """

        :return:
        """
        pass


    def get_list_of_reactions(self, file_name):
        """

        :param file_name: Name of the model file (has to be xml for now)
        :return: None (prints the list of reactions that has mass in them)
        """

        # Load model¶depending on the kind of file (the file has to be xml)
        if file_name.endswith(".xml"):
            model = cobra.io.read_sbml_model(file_name)

        # Print out the reaction name and reaction id for all reactions related to BIOMASS production:
        print("List of reactions related to BIOMASS production:")
        for rxn in model.reactions:
            if rxn.name is not None and 'BIOMASS' in rxn.id:
                print("{}: {}".format(rxn.id, rxn.name))



    def get_optimized_solution(self, model, reaction_id):
        """

        :param model:
        :param reaction_id:
        :return solution:
        """

        # fix the flux value to -15 as we have data for this constraint
        model.reactions.get_by_id(reaction_id).lower_bound = self.LOWER_BOUND
        model.reactions.get_by_id(reaction_id).upper_bound = self.UPPER_BOUND
        # print(model.reactions.get_by_id(reaction_id))

        print("Displaying the reaction bounds after constraining them:")
        print(model.reactions.get_by_id(reaction_id).bounds)

        # optimizing the model for only the selected reaction   
        # model.slim_optimize()

        # optimizing model
        solution = model.optimize()

        return solution


    def read_model(self, file_name):
        """

        :param file_name:
        :return model:
        """

        # Load model¶depending on the kind of file
        if file_name.endswith(".xml"):
            model = cobra.io.read_sbml_model(file_name)
        elif file_name.endswith(".json"):
            model = cobra.io.load_json_model(file_name)

        return model
#==============================================================================

class Ropacus():

    def __init__(self):
        pass

    def add_random_noise(self):
        # TODO
        """

        :return:
        """
        pass

    def chemical_translation(self, dict_in: Dict[str, Any],
                             fmt_from: str = 'KEGG',
                             fmt_to: str = 'PubChem CID') -> Dict[str, Any]:
        """
        Proxy to UCDavis Chemical Translation Service (CTS). Maps the keys of
        the input dictionary keeping intact the values.

        Default behaviour: map KEGG Compounds into PubChem CIDs

        For details, see https://cts.fiehnlab.ucdavis.edu/services
        """

        dict_out: Dict[str, float] = {}
        print(gray('Mapping metabolites ids using CTS'), end='', flush=True)
        ids_in: List[str] = list(dict_in.keys())
        pattern = re.compile(
            r"""(?:"searchTerm":")(\w+)(?:","results":\[")(\w+)(?:"])""")
        for id_in in ids_in:
            mapping_str: str = f'{fmt_from}/{fmt_to}/{id_in}'
            mapping_data = urllib.parse.quote(mapping_str)
            mapping_req = urllib.request.Request(CTS_URL + mapping_data)
            with urllib.request.urlopen(mapping_req) as map_file:
                mapping = map_file.read().strip().decode('utf-8')
            match: re.Match = pattern.search(mapping)
            if match:
                assert match.group(1) == id_in
                id_out: str = match.group(2)
                if fmt_to == 'PubChem CID':
                    id_out = 'CID:' + id_out
                dict_out[id_out] = dict_in[id_in]
                print(green('.'), end='', flush=True)
                dprint(f'Metabolite {id_in} mapped to {id_out}')
            else:
                print(red('.'), end='', flush=True)
                dprint(yellow(f'Metabolite {id_in} mapping failed!'))
        print(green('OK!'))
        vprint(gray('Number of unmapped genes from'), fmt_from, gray('to'),
               fmt_to, gray(':'), yellow(len(dict_in) - len(dict_out)))
        return dict_out

    def dict_to_edd(self, omics_dict: Dict[str, float],
                    omics: Omics) -> pd.DataFrame:
        """Get dataframe with EDD format from dictionary with omics values"""

        edd: List[OrderedDict[str, Any]] = []
        sample: OrderedDict[str, Any]

        for measurement, value in omics_dict.items():
            sample = col.OrderedDict([
                ('Line Name', 'WT'),
                ('Measurement Type', measurement),
                ('Time', 0),  # TODO: Generalize for time-series
                ('Value', value),
                ('Units', UNITS[omics])
            ])
            edd.append(sample)

        return pd.DataFrame(edd)

    def dprint(self, *a, **k):
        """Print only if debug mode is enabled"""
        if args.debug:
            print(*a, **k)

    def generate_mock_data(self, model, cond):
        """

        :param model: cobra model object
        :param solution: solution for the model optimization using cobra
        :param data_type: defines the type of -omics data to generate (all by default)
        :return:
        """

        while cond:
            print(gray('Condition parameter:'), magenta(cond))
            cond -= 1
            self.optimize_solution(model, REACTION_ID)
            solution: cobra.Solution = cobra.core.solution.get_solution(
                model, raise_error=False)
            vprint(gray('Solution objective value:'), solution.objective_value)
            vprint(gray('Model summary after optimization:'))
            try:
                vprint(model.summary())
            #   vprint(model.metabolites.C00185_e.summary())
            except Infeasible:
                vprint(yellow(
                    'Model summary unavailable as solution was unfeasible!'))

            self.write_experiment_description(cond)
            self.get_omics_data(model, solution, cond)

    def gene_to_protein(self, dict_in: Dict[str, Any],
                        fmt_gene: str = 'KEGG_ID',
                        fmt_prot: str = 'ID') -> Dict[str, Any]:
        """
        From any dict whose keys are gene IDs, maps them to protein IDs and
        keeps the value intact


        Default behaviour: map KEGG IDs into UNIPROT IDs

        For details, see https://www.uniprot.org/help/api_idmapping
        """

        dict_out: Dict[str, float] = {}
        print(gray('Mapping genes into proteins using UNIPROT... '), end='')
        gene_ids: List[str] = list(dict_in.keys())
        mapping_params: Dict[str, str] = {
            'from': fmt_gene,
            'to': fmt_prot,
            'format': 'tab',
            'query': '\t'.join(gene_ids)
        }
        mapping_data = urllib.parse.urlencode(mapping_params)
        mapping_data = mapping_data.encode('utf-8')
        mapping_req = urllib.request.Request(UNIPROT_URL, mapping_data)
        with urllib.request.urlopen(mapping_req) as map_file:
            mapping = map_file.read().strip().decode('utf-8').split('\n')
        for gene2prot in mapping[1:]:
            gene, prot = gene2prot.split('\t', 1)
            dict_out[prot] = dict_in[gene]
            dprint('Gene', gene, 'mapped to protein', prot)
        if dict_out:
            print(green('OK!'))
            vprint(gray('Number of unmapped genes from'), fmt_gene, gray('to'),
                   fmt_prot, gray(':'), yellow(len(dict_in) - len(dict_out)))
        else:
            print(yellow('PROBLEM!'))
        return dict_out

    def get_omics_data(self, model: cobra.Model,
                       solution: cobra.Solution,
                       cond: int):
        """
        Core method that generates all omics data.

        :param model:
        :param solution:
        :param cond:
        :return:

        """
        # Pre-determined linear constants
        PROTE_SCALING: float = 10  # Scaling factor for fluxes to proteomics
        TRANS_SCALING: float = 1.2  # S.F. for proteomics to transcriptomics
        # TODO: Allow user to set those constants via parameters

        # The omics variable name should coincide with those elements of Omics
        proteomics: Dict[str, float] = {}
        transcriptomics: Dict[str, float] = {}
        metabolomics: Dict[str, float] = {}

        # Get values and statistics for proteomics and transcriptomics
        proteo_stats: Dict[str, Counter[str]] = {
            db + status: col.Counter() for db in GENE_IDS_DBS
            for status in ['_missing', '_success', '_zero']}
        metabolite_awflux: Dict[str, List[float]] = {}  # abs weighted fluxes

        rxn_ids: pd.Index = solution.fluxes.index
        # Cobra docs: Accessing reaction fluxes through a Solution object
        #  is the safer, preferred, and only guaranteed to be correct way.
        for rxn_id in rxn_ids:
            reaction: cobra.Reaction = model.reactions.get_by_id(rxn_id)
            flux: float = solution.fluxes[rxn_id]
            gene: cobra.Gene

            # Subloop 1/2: proteomics and transcriptomics
            for gene in reaction.genes:
                gene_id: str = ''
                # WARNING! Based on gene.annotation property populated
                gene_id_db: str = ''
                for gene_id_db in GENE_IDS_DBS:
                    try:
                        gene_id = gene.annotation[gene_id_db]
                    except KeyError:
                        proteo_stats[gene_id_db + '_missing'][gene_id] += 1
                    else:
                        # Populates proteomics and transcriptomics dicts if
                        #  related flux has a positive value
                        proteo: int = np.ceil(flux * PROTE_SCALING)
                        if proteo > _EPS:
                            # Accumulate in case of multiple genes
                            try:
                                proteomics[gene_id] += proteo
                            except KeyError:
                                proteomics[gene_id] = proteo
                            proteo_stats[gene_id_db + '_success'][gene_id] += 1
                        else:
                            proteo_stats[gene_id_db + '_zero'][gene_id] += 1
                        transc: float = proteo * TRANS_SCALING
                        if transc > _EPS * 1e+3:
                            transcriptomics[gene.id] = transc
                        break
                else:
                    dprint(yellow('WARNING!'), gray('Gene'), gene.id,
                           gray('in reaction'), rxn_id,
                           gray('has no useful annotation. Skipping...'))

            # Subloop 2/2: metabolomics (partial)
            for metabolite, coeff in reaction.metabolites.items():
                awflux: float = abs(coeff * flux)  # absolute weighted flux
                if awflux < _EPS:
                    continue
                metabolite_id: str = metabolite.id.rsplit(
                    sep='_', maxsplit=1)[0]  # Remove suffixes _c, _e, etc
                try:
                    metabolite_awflux[metabolite_id].append(awflux)
                except KeyError:
                    metabolite_awflux[metabolite_id] = [awflux]

        # Metabolomics (final)
        # Alt: to avoid this loop use a moving average in the subloop above
        for metabolite, awfluxes in metabolite_awflux.items():
            metabolomics[metabolite] = statistics.mean(awfluxes)
        vprint(gray('Number of active metabolites:'), len(metabolomics))

        dprint(gray('Number of fluxes related to each gene (top 10)'))
        for gene_id_db in GENE_IDS_DBS:
            for status in ['_missing', '_success', '_zero']:
                dprint(gene_id_db + status, proteo_stats[
                    gene_id_db + status].most_common(10))

        # Map genes ids into protein ids accepted by EDD
        proteomics = gene_to_protein(proteomics)

        # Map metabolites ids into those accepted by EDD
        metabolomics = chemical_translation(metabolomics)

        # Write omics files
        for omic in Omics:  # NOTE: omics variable names are elements of Omics
            omics_df: pd.DataFrame = dict_to_edd(eval(str(omic)), omic)
            write_data_files(omics_df, omic, cond)

    def get_random_number(self):
        """

        :return:
        """
        random.seed(12312)
        return random.random()

    def optimize_solution(self, model: cobra.Model, reaction_id: str) -> None:
        """

        :param model:
        :param reaction_id:
        :return solution:
        """

        reaction: cobra.Reaction = model.reactions.get_by_id(reaction_id)
        vprint(gray('Reaction:'), reaction)
        if args.debug:
            print(blue('List of reactants:'))
            for reactant in reaction.reactants:
                print(reactant, reactant.name)
            print(blue('List of products:'))
            for product in reaction.products:
                print(product, product.name)


        # Set local reaction bounds
        model.reactions.get_by_id(reaction_id).lower_bound = LOWER_BOUND
        model.reactions.get_by_id(reaction_id).upper_bound = UPPER_BOUND
        vprint(gray('Displaying the reaction bounds after constraining them:'),
               blue(model.reactions.get_by_id(reaction_id).bounds))
        # Optimize the model using FBA
        print(gray('Optimizing the model using FBA... '), end='')
        model.slim_optimize()
        try:
            cobra.util.assert_optimal(model)
        except OptimizationError as error:
            print(yellow('PROBLEM!'), error)
        else:
            print(green('OK!'))

    def read_model(self, file_name):
        """

        :param file_name:
        :return model:
        """

        # Check presence of model file
        if not os.path.isfile(file_name):
            print(red('ERROR!'),
                  f'File {file_name} missing from the data dir!')
            raise IOError('Missing file')

        # Load model depending on the kind of file
        vprint(gray(f'Loading model in {file_name}... '), end='')
        if file_name.endswith('.xml') or file_name.endswith('.sbml'):
            model = cobra.io.read_sbml_model(file_name)
        elif file_name.endswith('.json'):
            model = cobra.io.load_json_model(file_name)
        else:
            print(red('ERROR!'),
                  f'File {file_name} type not supported!')
            raise TypeError('Unsupported file format')
        vprint(green('OK!'))

        return model

    def vprint(self, *a, **k):
        """Print only if verbose mode is enabled"""
        if args.verbose:
            print(*a, **k)

    def write_data_files(self, edd: pd.DataFrame, omics: Omics = None,
                         cond: int = 1) -> None:
        """
        Write the EDD dataframe into a xlsx file

        :param edd:
        :param omics:
        :param cond:
        :return:
        """
        omics_fname: Filename = Filename(
            os.path.join(DATA_FILE_PATH,
                         f'{omics}_mock{cond}.xlsx'))
        print(gray('Saving file'), magenta(omics_fname), gray('... '), end='')
        try:
            edd.to_excel(omics_fname,
                         sheet_name=f'{omics}',
                         index=False)
        except IOError as ex:
            print(red('ERROR!'))
            vprint(ex)
        else:
            print(green('OK!'))

    def write_experiment_description(self, cond=1):
        """

        :param cond:
        :return:
        """

        exp_desc_fname: Filename = Filename(
            os.path.join(
                DATA_FILE_PATH,
                f'EDD_Omics_Experiment_Description_mock{cond}.xlsx'))
        index_label = 'Line Name'
        exp_desc_cols = pd.Index([
            'Line Description',
            'Media',
            'Shaking speed',
            'Starting OD',
            'Culture Volume',
            'Flask Volume',
            'Growth Temperature',
            'Replicate Count',
        ], name=index_label)
        metadata_wt: Dict[str, Dict[str, Any]] = {'WT': {
            'Line Description': 'R. Opacus PD630 wild type (mock)',
            'Media': 'Mock media',
            'Shaking speed': 1.0,
            'Starting OD': 0.1,
            'Culture Volume': 50.0,
            'Flask Volume': 200.0,
            'Growth Temperature': 30.0,
            'Replicate Count': 1,
        }}
        exp_desc_df = pd.DataFrame.from_dict(metadata_wt,
                                             orient='index',
                                             columns=exp_desc_cols)
        print(gray('Saving file'), magenta(exp_desc_fname),
              gray('... '), end='')
        try:
            exp_desc_df.to_excel(exp_desc_fname,
                                 sheet_name='EXP_DESC',
                                 index_label=index_label)
        except IOError as ex:
            print(red('ERROR!'))
            vprint(ex)
        else:
            print(green('OK!'))

#======================================

def main():
    """Main entry point to the script."""

    def check_debug():
        """Check debugging mode"""
        if args.debug:
            print(blue('INFO:'), gray('Debugging mode activated'))
            print(blue('INFO:'), gray('Active parameters:'))
            for key, val in vars(args).items():
                if val is not None and val is not False and val != []:
                    print(gray(f'\t{key} ='), f'{val}')
            args.verbose = True  # Unconditional verbose mode activation
        elif not sys.warnoptions:
            warnings.simplefilter("ignore")

    def print_reactions(model):
        """

        :param model:
        :return: None (prints the list of reactions that have BIOMASS in them)
        """

        # Print out the reaction name and reaction id for all reactions
        #   related to BIOMASS production:
        vprint(gray('List of reactions related to BIOMASS production:'))
        for rxn in model.reactions:
            if rxn.name is not None and 'biomass' in rxn.id.lower():
                vprint(f"{rxn.id} : {rxn.name}")

    # def generate_time_series_data(model):

    #     # generating time series data for the following flux constraints
    #     # 3, 6, 9, 10, 15 corresponding to the times 0, 3, 6, 9 hours

    #     for flux_constraint in range(6, 16, 3):
    #         # Set global reactions bounds (in addition to local)
    #         LOWER_BOUND = flux_constraint
    #         UPPER_BOUND = flux_constraint
    #         cobra_config = cobra.Configuration()
    #         cobra_config.bounds = LOWER_BOUND, UPPER_BOUND

    #         # Print the list of reaction names related to BIOMASS production
    #         print_reactions(model)

    #         # get fake proteomics data and write it to XLSX file
    #         condition = 1
    #         generate_mock_data(model, condition)


    def generate_data_for_host(filename):
        """
            Generate omics data for host and model name
        """
        if HOST_NAME == 'ecoli':
            # create instance of the E. Coli class
            ecoli = Ecoli()

            # read model file
            model = ecoli.read_model(filename)

            # generate ecoli synthetic data for model and condition
            condition = 1
            ecoli.generate_time_series_data(model, condition)

        elif HOST_NAME == 'ropacus':
            # create instance of the E. Coli class
            rop = Ropacus()

            # read model file
            model = rop.read_model(filename)

            # generate time series mock data for host
            generate_time_series_data(model)

    
    # Argument Parser Configuration
    parser = argparse.ArgumentParser(
        description='Omics Mock Generator',
        epilog='%(prog)s -- {}'.format(__date__),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        '-d', '--debug',
        action='store_true',
        help='enable debug mode (implies verbose mode)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='enable verbose mode'
    )
    parser.add_argument(
        '-V', '--version',
        action='version',
        version='%(prog)s release {} ({})'.format(__version__, __date__)
    )
    parser.add_argument(
        '-ho', '--host',
        default='ecoli',
        help='specify host organism'
    )
    parser.add_argument(
        '-mf', '--modelfile',
        default='iJO1366.json',
        help='specify model file to use, should be in data folder'
    )

    # Parse arguments
    args = parser.parse_args()

    # Program header
    print('\n=-= {} =-= v{} - {} =-= by {} =-=\n'.format(
        sys.argv[0], __version__, __date__, __author__))

    # Select cases depending on the debug flag
    check_debug()

    # if data folder doesn't exist create it
    if not os.path.isdir(DATA_FILE_PATH):
        os.mkdir(DATA_FILE_PATH)

    # check if host and model file has been mentioned
    HOST_NAME = args.host
    MODEL_FILENAME = args.modelfile

    filename: Filename = Filename(os.path.join(DATA_FILE_PATH, MODEL_FILENAME))
    # reaction_id = 'EX_glc__D_e'
    
    # get time series omics data for specified host and model
    generate_data_for_host(filename)


if __name__ == "__main__":
    # TODO: Ask for filename and reaction name and then generate the mock data
    main()
